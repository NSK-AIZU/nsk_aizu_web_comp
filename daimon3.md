# 第3問 解説 (25点)

## 目次
- [問1](#問1)
- [問2](#問2)
- [問3](#問3)

---

## 問1

### 問題概要
工芸品製作のスケジューリングにおいて、レシートから製作期間を読み取り、空欄を埋める問題

### 解答
- **ア**: 2 (部員2)
- **イ**: 2 (2日目)
- **ウ**: 2 (部員2)
- **エ**: 3 (3日目)
- **オ**: 5 (5日目)

### 解説

#### 基本情報の整理
- 表1：各工芸品（1〜9）の製作日数
- 図1：レシート形式で各工芸品の担当部員と期間を表示
- ルール：一つの工芸品は一人の部員が担当し、完了するまで他の工芸品に取り掛からない

#### ア・イ：工芸品4の担当部員と開始日

図1（レシートの例）を見ると：
- **部員1**：工芸品1を1日目〜4日目（4日間）
- **部員2**：工芸品2を1日目〜1日目（1日間）、その後工芸品4
- **部員3**：工芸品3を1日目〜3日目（3日間）

表1より、工芸品4の製作日数は**1日**です。

部員2は工芸品2を1日目で終えるため、2日目から空きになります。したがって、工芸品4は部員2が2日目から担当します。

- **ア = 2**（部員2）
- **イ = 2**（2日目）

#### ウ・エ・オ：工芸品5の担当部員と期間

ルール：「最も早く空きになる部員（複数いる場合はそのうち最小の番号の部員）が、空きになった日付から次の工芸品を担当する」

**工芸品4まで の終了時点**：
- 部員1：1〜4日目（工芸品1）→ 5日目から空き
- 部員2：1日目（工芸品2）、2日目（工芸品4）→ 3日目から空き
- 部員3：1〜3日目（工芸品3）→ 4日目から空き

**工芸品5の担当**：
- 最も早く空きになるのは部員2（3日目から）
- 工芸品5の製作日数は3日間（表1より）
- 担当：部員2、期間：3日目〜5日目

- **ウ = 2**（部員2）
- **エ = 3**（3日目）
- **オ = 5**（5日目）

### ポイント
- **スケジューリングの基本**：リソース（部員）の空き状況を管理
- **優先順位ルール**：複数の候補がある場合の選択基準を明確にする
- **レシート形式の読み取り**：開始日〜終了日の期間を正確に読み取る

---

## 問2

### 問題概要
配列`Akibi`を使って各部員の空き日を管理し、最も早く空く部員を見つけるプログラムを理解する問題

### 解答
- **カ**: 4 (日目)
- **キ**: 1 (`Akibi[buin] < Akibi[tantou]`)
- **ク**: 1 (1回)

### 解説

#### 配列Akibiの説明
- **添字**：部員の番号（1から始まる）
- **要素**：その部員が空きになる日付

例：`Akibi[1] = 5` → 部員1は5日目から空き

#### カ：図1の状況での配列Akibi

図1（工芸品4まで割り当て済み）の状況：
- **部員1**：工芸品1（1〜4日目）→ 5日目から空き → `Akibi[1] = 5`
- **部員2**：工芸品2（1日目）、工芸品4（2日目）→ 3日目から空き → `Akibi[2] = 3`
- **部員3**：工芸品3（1〜3日目）→ 4日目から空き → `Akibi[3] = ?`

部員3は工芸品3を3日間（1〜3日目）製作するため、4日目から空きになります。

**カ = 4**

#### キ：最も早く空く部員を見つける条件

図4のプログラムを見ると、最も早く空く部員を見つけるロジックが示されています：

```
(01) tantou = 1
(02) buin を 2 から buinsu まで 1 ずつ増やしながら繰り返す:
(03)     もし キ ならば:
(04)         tantou = buin
```

このプログラムの動作：
1. 最初に`tantou = 1`（部員1を仮の担当者とする）
2. 部員2以降と比較していく
3. もし`buin`の方が早く空くなら、`tantou`を更新する

「`buin`の方が早く空く」という条件は：
```
Akibi[buin] < Akibi[tantou]
```

つまり、`buin`の空き日が`tantou`の空き日より小さい（早い）ということです。

選択肢：
- ⓪ `Akibi[tantou] < Akibi[buin]`
- ① `Akibi[buin] < Akibi[tantou]`
- ② `tantou < buin`
- ③ `buin < tantou`

**キ = 1** (`Akibi[buin] < Akibi[tantou]`)

#### ク：tantouへの代入回数

問題文の例：`Akibi = [5, 6, 4, 4, 4]`、`buinsu = 5`の場合

プログラムの実行過程：

**初期化**：
- `tantou = 1`（Akibi[1] = 5）

**ループ（buin = 2〜5）**：

- **buin = 2**: 
  - 条件：`Akibi[2] < Akibi[1]` → `6 < 5` → **偽**
  - 代入なし

- **buin = 3**: 
  - 条件：`Akibi[3] < Akibi[1]` → `4 < 5` → **真**
  - `tantou = 3`に更新 **← 1回目の代入**

- **buin = 4**: 
  - 条件：`Akibi[4] < Akibi[3]` → `4 < 4` → **偽**
  - 代入なし

- **buin = 5**: 
  - 条件：`Akibi[5] < Akibi[3]` → `4 < 4` → **偽**
  - 代入なし

**結果**：
- 最終的に`tantou = 3`（部員3が最も早く空く）
- (04)行の代入は**1回**だけ実行された

**ク = 1**

### ポイント
- **配列の活用**：各部員の状態を効率的に管理
- **添字と要素の対応**：添字が部員番号、要素が空き日付
- **期間計算**：開始日 + 製作日数 = 次の空き日
- **最小値探索アルゴリズム**：リストから最小値を持つ要素を見つける典型的なパターン
- **条件分岐の理解**：等号（<）と不等号（≤）の違いに注意

---

## 問3

### 問題概要
図5のプログラムの空欄を埋めて、工芸品の担当部員と期間を表示するプログラムを完成させる問題

### 解答
- **ケ**: 1 (kougeihin)
- **コ**: 4 (kougeihinsu)
- **キ**: 1 (`Akibi[buin] < Akibi[tantou]`)
- **ク**: 1 (1回)
- **サ**: 2 (`Nissu[kougeihin] - 1`)
- **シ**: 0 (`Nissu[kougeihin]`)

### 解説

#### プログラムの全体構造

```
(01) Nissu = [4, 1, 3, 1, 3, 4, 2, 4, 3]
(02) kougeihinsu = 9
(03) Akibi = [1, 1, 1]
(04) buinsu = 3
(05) ケ を 1 から コ まで 1 ずつ増やしながら繰り返す;
(06)     tantou = 1
(07)     buin を 2 から buinsu まで 1 ずつ増やしながら繰り返す;
(08)         もし キ ならば;
(09)             tantou = buin
(10)     表示する("工芸品", kougeihin, "...", 
                "部員", tantou, ":", 
                Akibi[tantou], "日目~", 
                Akibi[tantou] + サ, "日目")
(11)     Akibi[tantou] = Akibi[tantou] + シ
```

#### ケ・コ：繰り返しの範囲

このプログラムは全ての工芸品（1〜9）について、担当部員と期間を決定します。

- 工芸品は1番から順に処理
- 工芸品の総数は`kougeihinsu = 9`

したがって：
- **ケ = 1**（kougeihin）：工芸品の番号を表す変数
- **コ = 4**（kougeihinsu）：工芸品の総数

選択肢：
- ⓪ buin、① kougeihin、② tantou
- ③ buinsu、④ kougeihinsu

**ケ = ①、コ = ④**

#### キ：最も早く空きになる部員の判定条件

(06)〜(09)行は、問2の図4のプログラムと同様に、最も早く空きになる部員を見つけるロジックです。

```
tantou = 1  # 初期値：部員1
for buin in [2, 3]:  # 部員2, 3と比較
    if Akibi[buin] < Akibi[tantou]:  # buinの方が早く空くなら
        tantou = buin  # 担当をbuinに更新
```

条件：「buinの空き日がtantouの空き日より早い」

**キ = ①** (`Akibi[buin] < Akibi[tantou]`)

#### ク：代入回数

問2で説明があったように、`Akibi = [5, 6, 4, 4, 4]`、`buinsu = 5`の場合を追跡します。

- `tantou = 1`（Akibi[1] = 5）
- `buin = 2`: Akibi[2] = 6 < 5? → No（更新なし）
- `buin = 3`: Akibi[3] = 4 < 5? → Yes（`tantou = 3`に更新）**← 1回目**
- `buin = 4`: Akibi[4] = 4 < 4? → No（更新なし）
- `buin = 5`: Akibi[5] = 4 < 4? → No（更新なし）

最終結果：`tantou = 3`（部員3）

代入は**1回**だけ行われました。

**ク = 1**

#### サ・シ：終了日の計算と次の空き日の更新

(10)行で工芸品の製作期間を表示します：
```
Akibi[tantou], "日目~", Akibi[tantou] + サ, "日目"
```

例えば、工芸品1（製作日数4日）を部員1が1日目から製作する場合：
- 開始日：1日目
- 終了日：4日目（1 + 4 - 1 = 4）
- 次の空き日：5日目（1 + 4 = 5）

つまり：
- **終了日** = 開始日 + 製作日数 - 1
- **次の空き日** = 開始日 + 製作日数

(11)行で部員の次の空き日を更新：
```
Akibi[tantou] = Akibi[tantou] + シ
```

したがって：
- **サ = ②** (`Nissu[kougeihin] - 1`)：終了日の計算
- **シ = ⓪** (`Nissu[kougeihin]`)：次の空き日の更新

選択肢（サ・シ）：
- ⓪ `Nissu[kougeihin]`
- ① `Nissu[tantou]`
- ② `Nissu[kougeihin] - 1`
- ③ `Nissu[tantou] - 1`

**サ = 2、シ = 0**

### ポイント
- **配列の添字**：`Nissu[kougeihin]`は工芸品の製作日数、`Akibi[tantou]`は部員の空き日
- **期間の表現**：開始日〜終了日の計算方法（終了日 = 開始日 + 日数 - 1）
- **状態の更新**：次の工芸品のために、部員の空き日を更新する必要がある
- **ループと条件分岐**：プログラミングの基本構造を理解する

---

## 全体のポイント

### スケジューリング問題の特徴
1. **リソース管理**：限られたリソース（部員）を効率的に割り当てる
2. **時系列管理**：各タスクの開始・終了時刻を追跡
3. **制約条件**：一人の部員は同時に複数のタスクを担当できない

### プログラミング的思考
1. **データ構造の選択**：配列を使って状態を管理
2. **アルゴリズムの設計**：最も早く空きになる部員を見つけるロジック
3. **状態の更新**：各ステップで適切に状態を更新

### 実社会への応用
- **プロジェクト管理**：複数のタスクとメンバーのスケジューリング
- **製造業**：生産ラインの工程管理
- **サービス業**：従業員のシフト管理

このようなスケジューリング問題は、情報システムの基本的な応用例であり、実社会で広く使われています。
